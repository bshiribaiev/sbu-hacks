{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/shiribaiev/Library/CloudStorage/GoogleDrive-bekbolnyc%40gmail.com/My%20Drive/Coding/sbu-hacks/renderer/app/api/analyze-evidence/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\nimport { GoogleGenerativeAI } from '@google/generative-ai'\nimport fs from 'fs'\nimport path from 'path'\n\ninterface EvidencePoint {\n  id: string\n  label: string\n  description: string\n  position: [number, number, number]\n  category: 'object' | 'anomaly' | 'evidence' | 'furniture'\n  confidence: number\n}\n\nexport async function POST(request: Request) {\n  try {\n    const { sceneName, sceneDescription, modelUrl, screenshot } = await request.json()\n    const geminiApiKey = process.env.GEMINI_API_KEY\n\n    const hasValidApiKey = geminiApiKey && geminiApiKey !== 'your_api_key_here' && geminiApiKey.length > 10\n    console.log('Analyzing scene:', { \n      sceneName, \n      sceneDescription: sceneDescription.substring(0, 100), \n      hasScreenshot: !!screenshot,\n      hasApiKey: !!geminiApiKey,\n      apiKeyLength: geminiApiKey?.length || 0,\n      isValidApiKey: hasValidApiKey\n    })\n\n    // üöÄ DEMO MODE: Hardcoded evidence for Room scene ONLY (for presentation/testing)\n    const isDemoMode = sceneName.toLowerCase() === 'room'\n    if (isDemoMode) {\n      console.log('üéØ DEMO MODE: Using hardcoded evidence points for \"Room\" scene')\n      const demoEvidence: EvidencePoint[] = [\n        {\n          id: 'demo-1',\n          label: 'Deceased Individual',\n          description: 'Primary victim lying in the center-left area of the room. Critical evidence for determining cause and time of incident.',\n          position: [-1.8, 0.2, 0.5], // Far left side, floor level, mid-depth\n          category: 'evidence',\n          confidence: 0.95\n        },\n        {\n          id: 'demo-2',\n          label: 'Bottle (Below TV)',\n          description: 'Bottle located below television set on left side. May contain substances relevant to the investigation - priority for lab analysis.',\n          position: [-2.2, 0.3, -1.5], // Extreme left side, low height, back wall (below TV)\n          category: 'evidence',\n          confidence: 0.90\n        },\n        {\n          id: 'demo-3',\n          label: 'Grey Sofa',\n          description: 'Large furniture piece on the right side. Check for trace evidence, blood spatter, and positioning relative to victim.',\n          position: [-0.5, 0.6, 0.2], // Left of center, furniture height, mid-depth\n          category: 'furniture',\n          confidence: 0.88\n        },\n        {\n          id: 'demo-4',\n          label: 'Wall Opening/Damage',\n          description: 'Damaged section of wall at the back. Possible entry/exit point or structural damage related to incident.',\n          position: [0.3, 1.6, -2.0], // Center-right, high up, far back wall\n          category: 'anomaly',\n          confidence: 0.82\n        }\n      ]\n      \n      console.log('‚úÖ Returning demo evidence:', demoEvidence.length, 'points')\n      demoEvidence.forEach((point, i) => {\n        console.log(`  ${i+1}. ${point.label} at [${point.position.map(p => p.toFixed(2)).join(', ')}]`)\n      })\n      \n      return NextResponse.json({ evidence: demoEvidence, source: 'demo' })\n    }\n\n    // üöÄ HACKATHON PRIORITY: If screenshot provided, use Gemini Vision (BEST - actually sees the scene)\n    let evidencePoints: EvidencePoint[] = []\n    let source = 'mock'\n\n    if (screenshot && hasValidApiKey) {\n      console.log('üéØ Attempting Gemini Vision analysis from screenshot...')\n      try {\n        const visionEvidence = await analyzeWithGeminiVision(screenshot, sceneName, sceneDescription, geminiApiKey)\n        if (visionEvidence && visionEvidence.length > 0) {\n          evidencePoints = visionEvidence\n          source = 'gemini-vision'\n          console.log(`‚úÖ Using Gemini Vision: ${evidencePoints.length} evidence points from visual analysis`)\n          return NextResponse.json({ evidence: evidencePoints, source })\n        }\n      } catch (visionError) {\n        console.error('‚ùå Gemini Vision error:', visionError)\n        // Fall through to other methods\n      }\n    }\n\n    // Fallback: Try GLB extraction (GOOD - real positions but limited info)\n    if (modelUrl) {\n      console.log('üéØ Attempting GLB evidence extraction...')\n      const glbEvidence = await extractEvidenceFromGLB(modelUrl)\n      if (glbEvidence.length > 0) {\n        evidencePoints = glbEvidence\n        source = 'glb'\n        console.log(`‚úÖ Using GLB data: ${evidencePoints.length} evidence points extracted`)\n        return NextResponse.json({ evidence: evidencePoints, source })\n      }\n      console.log('‚ö†Ô∏è No evidence extracted from GLB, trying Gemini text...')\n    }\n\n    // If Gemini API key is available and valid, try to use it\n    if (hasValidApiKey) {\n      console.log('Attempting Gemini analysis...')\n      console.log('API Key format check:', {\n        startsWithAIza: geminiApiKey?.startsWith('AIza'),\n        length: geminiApiKey?.length,\n        firstChars: geminiApiKey?.substring(0, 10)\n      })\n      try {\n        const geminiEvidence = await analyzeWithGemini(sceneName, sceneDescription, geminiApiKey, modelUrl)\n        // Only use Gemini results if we got actual evidence points\n        if (geminiEvidence && geminiEvidence.length > 0) {\n          evidencePoints = geminiEvidence\n          source = 'gemini'\n          console.log('‚úÖ Using Gemini results:', evidencePoints.length, 'points')\n          return NextResponse.json({ evidence: evidencePoints, source })\n        }\n        console.log('‚ö†Ô∏è Gemini returned empty array, falling back to mock')\n      } catch (geminiError: any) {\n        console.error('‚ùå Gemini API error:', geminiError?.message || geminiError)\n        console.error('Full error:', geminiError)\n        \n        // Provide helpful error message\n        if (geminiError?.message?.includes('404')) {\n          console.error('üí° TIP: Your API key might not have access to gemini-pro.')\n          console.error('   Try getting a new API key from: https://makersuite.google.com/app/apikey')\n          console.error('   Or check if your API key has the right permissions.')\n        }\n        // Fall back to mock if Gemini fails\n      }\n    } else {\n      console.log('‚ÑπÔ∏è No valid Gemini API key found, using mock data')\n      console.log('   To use Gemini: Add GEMINI_API_KEY to .env.local')\n      console.log('   Get your key from: https://makersuite.google.com/app/apikey')\n    }\n\n    // Fallback to mock evidence points\n    console.log('Using mock evidence generation')\n    evidencePoints = generateEvidencePoints(sceneName, sceneDescription)\n    console.log('Generated mock evidence:', evidencePoints.length, 'points')\n    return NextResponse.json({ evidence: evidencePoints, source: 'mock' })\n  } catch (error) {\n    console.error('Error analyzing evidence:', error)\n    return NextResponse.json({ error: 'Failed to analyze evidence' }, { status: 500 })\n  }\n}\n\nasync function analyzeWithGemini(\n  sceneName: string,\n  sceneDescription: string,\n  apiKey: string,\n  modelUrl?: string\n): Promise<EvidencePoint[]> {\n  try {\n    const genAI = new GoogleGenerativeAI(apiKey)\n    \n    // Use gemini-1.5-flash (more reliable) or gemini-pro\n    // Try gemini-1.5-flash first as it's more available\n    let model\n    try {\n      model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' })\n      console.log('Using Gemini model: gemini-2.5-flash')\n    } catch (err) {\n      model = genAI.getGenerativeModel({ model: 'gemini-2.5-flahs' })\n      console.log('Using Gemini model: gemini-pro')\n    }\n\n    // Extract 3D model metadata if available\n    let modelMetadata = ''\n    if (modelUrl) {\n      try {\n        modelMetadata = await extractGLBMetadata(modelUrl)\n      } catch (error) {\n        console.log('Could not extract GLB metadata:', error)\n      }\n    }\n\n    // Build the prompt - use neutral language to avoid safety filters\n    const prompt = `You are analyzing a 3D scene reconstruction for investigation purposes.\n\nSCENE INFORMATION:\nScene Name: \"${sceneName}\"\nDescription: \"${sceneDescription}\"\n${modelMetadata ? `\\n3D MODEL STRUCTURE:\\n${modelMetadata}` : ''}\n\nTASK: Identify 3-4 important points of interest in this scene based on the description and objects present.\n\nFor each point, provide:\n- label: A clear name (e.g., \"Key Object Location\", \"Area of Interest\", \"Furniture Position\")\n- description: Why this location is significant (2 sentences)\n- position: 3D coordinates [x, y, z] where x=left/right, y=height, z=back/front (use values between -3 and 3)\n- category: One of \"evidence\", \"anomaly\", \"object\", or \"furniture\"\n- confidence: A number between 0.6 and 0.95\n\nReturn ONLY a valid JSON array in this format:\n[\n  {\n    \"label\": \"Example Point\",\n    \"description\": \"This area shows important details relevant to the scene investigation.\",\n    \"position\": [0.5, 0.5, -0.8],\n    \"category\": \"evidence\",\n    \"confidence\": 0.85\n  }\n]\n\nAnalyze scene: \"${sceneName}\"\nDescription: \"${sceneDescription}\"\n${modelMetadata ? `\\nObjects in scene:\\n${modelMetadata.split('\\n').slice(0, 10).join('\\n')}` : ''}\n\nReturn only the JSON array, no other text.`\n\n    console.log('Calling Gemini API with prompt length:', prompt.length)\n    console.log('Model metadata extracted:', modelMetadata ? 'Yes' : 'No')\n    \n    // Try the API call - if it fails, we'll fall back to mock\n    const result = await model.generateContent(prompt)\n    \n    const response = await result.response\n    const text = response.text()\n    \n    console.log('Gemini response received, length:', text.length)\n    console.log('Gemini response preview:', text.substring(0, 200))\n    \n    // Check if response was blocked by safety filters\n    if (!text || text.length === 0) {\n      console.warn('‚ö†Ô∏è Gemini returned empty response - may be blocked by safety filters')\n      console.log('Response candidates:', response.candidates)\n      console.log('Finish reason:', response.candidates?.[0]?.finishReason)\n      \n      // Check if blocked by safety\n      const finishReason = response.candidates?.[0]?.finishReason\n      if (finishReason === 'SAFETY' || finishReason === 'RECITATION') {\n        console.error('üö´ Response blocked by safety filters - try adjusting prompt')\n        throw new Error('Response blocked by safety filters')\n      }\n      \n      throw new Error('Empty response from Gemini')\n    }\n\n    // Parse Gemini's JSON response\n    try {\n      // Clean the response (remove markdown code blocks if present)\n      let cleanedText = text\n        .replace(/```json\\n?/g, '')\n        .replace(/```\\n?/g, '')\n        .trim()\n      \n      // Find the JSON array in the response (look for outermost [ and ])\n      const firstBracket = cleanedText.indexOf('[')\n      const lastBracket = cleanedText.lastIndexOf(']')\n      \n      if (firstBracket !== -1 && lastBracket !== -1 && lastBracket > firstBracket) {\n        cleanedText = cleanedText.substring(firstBracket, lastBracket + 1)\n      }\n      \n      console.log('Cleaned text for parsing:', cleanedText.substring(0, 300))\n      console.log('Full cleaned text length:', cleanedText.length)\n      const parsed = JSON.parse(cleanedText)\n\n      if (Array.isArray(parsed)) {\n        // Transform to EvidencePoint format\n        return parsed.map((item, index) => ({\n          id: `gemini-${index + 1}`,\n          label: item.label || 'Unknown',\n          description: item.description || '',\n          position: Array.isArray(item.position) && item.position.length === 3\n            ? item.position as [number, number, number]\n            : [0, 0, 0],\n          category: ['object', 'anomaly', 'evidence', 'furniture'].includes(item.category)\n            ? item.category as EvidencePoint['category']\n            : 'evidence',\n          confidence: typeof item.confidence === 'number' ? Math.max(0, Math.min(1, item.confidence)) : 0.7,\n        }))\n      }\n    } catch (parseError) {\n      console.error('Failed to parse Gemini response:', parseError)\n      console.error('Raw response:', text)\n    }\n\n    return []\n  } catch (error) {\n    console.error('Gemini API error:', error)\n    throw error\n  }\n}\n\n// üéØ HACKATHON WOW FACTOR: Gemini Vision - Actually analyzes the visual 3D scene!\nasync function analyzeWithGeminiVision(\n  screenshot: string, // base64 image data\n  sceneName: string,\n  sceneDescription: string,\n  apiKey: string\n): Promise<EvidencePoint[]> {\n  try {\n    console.log('üîç Gemini Vision: Analyzing screenshot...')\n    const genAI = new GoogleGenerativeAI(apiKey)\n    \n    // Use gemini-pro which supports multimodal (image + text) in current SDK\n    const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' })\n    console.log('Using Gemini model for vision: gemini-2.5-flash')\n    \n    // Remove data URL prefix if present (data:image/png;base64,)\n    const base64Data = screenshot.replace(/^data:image\\/\\w+;base64,/, '')\n    \n    const prompt = `You are analyzing a 3D crime scene reconstruction IMAGE from an AERIAL/ANGLED camera view.\n\nSCENE: ${sceneName}\nDESCRIPTION: ${sceneDescription}\n\nCRITICAL TASK: Identify ONLY the 4-5 MOST IMPORTANT evidence items you can clearly see.\nFocus on the most obvious, significant objects - NOT every small detail.\n\n3D COORDINATE SYSTEM (looking down at room from above/angle):\n- X axis: LEFT edge of image = -2, CENTER = 0, RIGHT edge = +2\n- Y axis: Floor/ground level = 0.3, Waist height = 0.8, Standing height = 1.7\n- Z axis: TOP of image (far away) = -2, BOTTOM of image (close to camera) = +2\n\nPOSITIONING GUIDE:\n- Objects HIGHER in the image ‚Üí more NEGATIVE Z (farther away, like -1.5)\n- Objects LOWER in the image ‚Üí more POSITIVE Z (closer, like +1.5)\n- Use the center of each object for position\n- Most furniture sits at Y = 0.5 to 0.8\n\nPRIORITY ORDER (pick 4-5):\n1. Bodies/people (HIGHEST priority - \"evidence\")\n2. Weapons or suspicious objects (\"evidence\")\n3. Large furniture pieces that frame the scene (\"furniture\")\n4. Notable anomalies like doors, windows, damage (\"anomaly\")\n\nReturn JSON array with ONLY 4-5 items:\n[\n  {\n    \"label\": \"Specific descriptive name\",\n    \"description\": \"Why this is important evidence (1-2 sentences)\",\n    \"position\": [x, y, z],\n    \"category\": \"evidence\" | \"furniture\" | \"anomaly\" | \"object\",\n    \"confidence\": 0.7-0.95\n  }\n]\n\nRULES:\n- ONLY include items you can CLEARLY see\n- Focus on LARGE, OBVIOUS objects (not small details)\n- Use CAREFUL position estimates - think about image top=far, bottom=near\n- Return ONLY valid JSON, no markdown, no extra text`\n\n    console.log('Sending screenshot to Gemini Vision (size:', base64Data.length, 'chars)')\n    \n    const result = await model.generateContent([\n      prompt,\n      {\n        inlineData: {\n          data: base64Data,\n          mimeType: 'image/png'\n        }\n      }\n    ])\n    \n    const response = await result.response\n    const text = response.text()\n    \n    console.log('Vision response received, length:', text.length)\n    console.log('Vision response preview:', text.substring(0, 200))\n    \n    if (!text || text.length === 0) {\n      console.warn('‚ö†Ô∏è Gemini Vision returned empty response')\n      return []\n    }\n    \n    // Parse response\n    try {\n      let cleanedText = text\n        .replace(/```json\\n?/g, '')\n        .replace(/```\\n?/g, '')\n        .trim()\n      \n      const firstBracket = cleanedText.indexOf('[')\n      const lastBracket = cleanedText.lastIndexOf(']')\n      \n      if (firstBracket !== -1 && lastBracket !== -1 && lastBracket > firstBracket) {\n        cleanedText = cleanedText.substring(firstBracket, lastBracket + 1)\n      }\n      \n      const parsed = JSON.parse(cleanedText)\n      \n      if (Array.isArray(parsed)) {\n        let evidencePoints: EvidencePoint[] = parsed.map((item, index) => ({\n          id: `vision-${index + 1}`,\n          label: item.label || 'Unknown',\n          description: item.description || '',\n          position: (Array.isArray(item.position) && item.position.length === 3\n            ? item.position\n            : [0, 0, 0]) as [number, number, number],\n          category: ['object', 'anomaly', 'evidence', 'furniture'].includes(item.category)\n            ? item.category as EvidencePoint['category']\n            : 'object',\n          confidence: typeof item.confidence === 'number' ? Math.max(0, Math.min(1, item.confidence)) : 0.75,\n        }))\n        \n        // Filter: Only keep high-confidence items (>= 0.7)\n        evidencePoints = evidencePoints.filter(point => point.confidence >= 0.7)\n        \n        // Sort by confidence (highest first) and limit to top 5\n        evidencePoints = evidencePoints\n          .sort((a, b) => b.confidence - a.confidence)\n          .slice(0, 5)\n        \n        console.log(`‚úÖ Parsed ${evidencePoints.length} high-confidence evidence points from Vision AI`)\n        evidencePoints.forEach((point, i) => {\n          console.log(`  ${i+1}. ${point.label} at [${point.position.map(p => p.toFixed(2)).join(', ')}] (confidence: ${(point.confidence * 100).toFixed(0)}%)`)\n        })\n        \n        return evidencePoints\n      }\n    } catch (parseError) {\n      console.error('Failed to parse Vision response:', parseError)\n      console.error('Raw response:', text)\n    }\n    \n    return []\n  } catch (error) {\n    console.error('Gemini Vision API error:', error)\n    throw error\n  }\n}\n\nasync function extractGLBMetadata(modelUrl: string): Promise<string> {\n  try {\n    // Extract file path from URL (remove /models/ prefix)\n    const filePath = modelUrl.replace('/models/', '')\n    const fullPath = path.join(process.cwd(), 'public', 'models', filePath)\n\n    if (!fs.existsSync(fullPath)) {\n      return 'Model file not found'\n    }\n\n    const stats = fs.statSync(fullPath)\n    const fileName = path.basename(fullPath)\n    const sceneName = fileName.replace('.glb', '').replace(/-/g, ' ')\n    \n    // Try to parse GLB file to extract object information\n    // GLB is a binary format: header + JSON chunk + binary chunk\n    const buffer = fs.readFileSync(fullPath)\n    \n    // Read GLB header (first 12 bytes)\n    if (buffer.length < 12) {\n      return `Invalid GLB file: ${fileName}`\n    }\n\n    const magic = buffer.readUInt32LE(0)\n    const version = buffer.readUInt32LE(4)\n    const length = buffer.readUInt32LE(8)\n\n    if (magic !== 0x46546C67) { // \"glTF\" in ASCII\n      return `Not a valid GLB file: ${fileName}`\n    }\n\n    // Read JSON chunk (starts at byte 12)\n    if (buffer.length < 20) {\n      return `GLB file too small: ${fileName}`\n    }\n\n    const jsonChunkLength = buffer.readUInt32LE(12)\n    const jsonChunkType = buffer.readUInt32LE(16)\n\n    if (jsonChunkType !== 0x4E4F534A) { // \"JSON\" in ASCII\n      return `Invalid GLB structure: ${fileName}`\n    }\n\n    // Extract JSON data\n    const jsonStart = 20\n    const jsonData = buffer.slice(jsonStart, jsonStart + jsonChunkLength)\n    const gltfJson = JSON.parse(jsonData.toString('utf8'))\n\n    // Extract useful information\n    const nodes = gltfJson.nodes || []\n    const meshes = gltfJson.meshes || []\n    const materials = gltfJson.materials || []\n    \n    const objectList: string[] = []\n    \n    // Extract node names and positions\n    nodes.forEach((node: any, index: number) => {\n      const name = node.name || `Node_${index}`\n      const position = node.translation || [0, 0, 0]\n      const meshIndex = node.mesh\n      \n      if (meshIndex !== undefined && meshes[meshIndex]) {\n        const meshName = meshes[meshIndex].name || `Mesh_${meshIndex}`\n        objectList.push(`${name} (${meshName}) at position [${position[0]?.toFixed(2) || 0}, ${position[1]?.toFixed(2) || 0}, ${position[2]?.toFixed(2) || 0}]`)\n      } else if (name) {\n        objectList.push(`${name} at position [${position[0]?.toFixed(2) || 0}, ${position[1]?.toFixed(2) || 0}, ${position[2]?.toFixed(2) || 0}]`)\n      }\n    })\n\n    return `3D MODEL METADATA:\nScene: ${sceneName}\nFile: ${fileName}\nSize: ${(stats.size / 1024 / 1024).toFixed(2)} MB\nFormat: GLB v${version}\n\nOBJECTS IN SCENE:\n${objectList.length > 0 ? objectList.slice(0, 20).join('\\n') : 'No named objects found'}\n${objectList.length > 20 ? `\\n... and ${objectList.length - 20} more objects` : ''}\n\nTotal Nodes: ${nodes.length}\nTotal Meshes: ${meshes.length}\nTotal Materials: ${materials.length}`\n  } catch (error) {\n    // If parsing fails, return basic info\n    try {\n      const filePath = modelUrl.replace('/models/', '')\n      const fullPath = path.join(process.cwd(), 'public', 'models', filePath)\n      const stats = fs.statSync(fullPath)\n      const fileName = path.basename(fullPath)\n      return `3D Model: ${fileName.replace('.glb', '')}\nFile: ${fileName}\nSize: ${(stats.size / 1024 / 1024).toFixed(2)} MB\nNote: Could not parse GLB structure - ${error}`\n    } catch {\n      return `Error reading model metadata`\n    }\n  }\n}\n\nfunction categorizeByName(name: string): EvidencePoint['category'] {\n  const lower = name.toLowerCase()\n  if (lower.includes('body') || lower.includes('blood') || lower.includes('weapon') || \n      lower.includes('knife') || lower.includes('gun')) return 'evidence'\n  if (lower.includes('chair') || lower.includes('table') || lower.includes('bed') || \n      lower.includes('mattress') || lower.includes('furniture')) return 'furniture'\n  if (lower.includes('door') || lower.includes('window') || lower.includes('entrance')) return 'anomaly'\n  return 'object'\n}\n\nfunction formatNodeName(name: string): string {\n  // \"body\" -> \"Body Evidence\"\n  // \"chairBanana\" -> \"Chair Banana\"\n  return name\n    .replace(/([A-Z])/g, ' $1') // camelCase to spaces\n    .replace(/[-_]/g, ' ') // dashes/underscores to spaces\n    .split(' ')\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join(' ')\n    .trim()\n}\n\n// üöÄ HACKATHON OPTIMIZATION: Extract real evidence points from GLB file\nasync function extractEvidenceFromGLB(modelUrl: string): Promise<EvidencePoint[]> {\n  try {\n    const filePath = modelUrl.replace('/models/', '')\n    const fullPath = path.join(process.cwd(), 'public', 'models', filePath)\n\n    if (!fs.existsSync(fullPath)) {\n      console.log('GLB file not found for evidence extraction')\n      return []\n    }\n\n    // üéØ HACKATHON ENHANCEMENT: If this is a room/scene file, scan the folder for individual evidence items\n    const fileName = path.basename(fullPath, '.glb')\n    const folderPath = path.dirname(fullPath)\n    const isMainScene = fileName === 'room' || fileName === 'bathroom' || fileName === 'dark-room'\n    \n    if (isMainScene && fs.existsSync(folderPath)) {\n      console.log(`üîç Scanning folder for individual evidence items: ${folderPath}`)\n      const allEvidence: EvidencePoint[] = []\n      \n      try {\n        const files = fs.readdirSync(folderPath)\n        const evidenceFiles = files.filter(f => \n          f.endsWith('.glb') && \n          f !== `${fileName}.glb` && // Skip the main scene file\n          !f.startsWith('dark-') // Skip dark variants\n        )\n        \n        console.log(`Found ${evidenceFiles.length} individual evidence files`)\n        \n        for (const evidenceFile of evidenceFiles) {\n          const evidencePath = path.join(folderPath, evidenceFile)\n          const evidence = await extractSingleGLB(evidencePath)\n          if (evidence.length > 0) {\n            allEvidence.push(...evidence)\n          }\n        }\n        \n        if (allEvidence.length > 0) {\n          console.log(`‚úÖ Extracted ${allEvidence.length} evidence points from folder scan`)\n          return allEvidence\n        }\n      } catch (error) {\n        console.error('Error scanning folder:', error)\n        // Fall through to single file extraction\n      }\n    }\n\n    // Fall back to extracting from single file\n    return await extractSingleGLB(fullPath)\n  } catch (error) {\n    console.error('Error extracting evidence from GLB:', error)\n    console.error('Stack:', error instanceof Error ? error.stack : error)\n    return []\n  }\n}\n\n// Helper function to extract evidence from a single GLB file\nasync function extractSingleGLB(fullPath: string): Promise<EvidencePoint[]> {\n  try {\n    const buffer = fs.readFileSync(fullPath)\n    \n    if (buffer.length < 20) return []\n\n    const magic = buffer.readUInt32LE(0)\n    if (magic !== 0x46546C67) return [] // Not a valid GLB\n\n    const jsonChunkLength = buffer.readUInt32LE(12)\n    const jsonChunkType = buffer.readUInt32LE(16)\n\n    if (jsonChunkType !== 0x4E4F534A) return [] // Invalid structure\n\n    const jsonStart = 20\n    const jsonData = buffer.slice(jsonStart, jsonStart + jsonChunkLength)\n    const gltfJson = JSON.parse(jsonData.toString('utf8'))\n\n    const nodes = gltfJson.nodes || []\n    const meshes = gltfJson.meshes || []\n    const accessors = gltfJson.accessors || []\n    const evidencePoints: EvidencePoint[] = []\n    \n    // üéØ HACKATHON TIP: Use filename if nodes don't have good names\n    const fileName = path.basename(fullPath, '.glb')\n    const defaultName = formatNodeName(fileName)\n\n    // Helper function to calculate mesh center from bounding box\n    const getMeshCenter = (meshIndex: number): [number, number, number] => {\n      try {\n        const mesh = meshes[meshIndex]\n        if (!mesh?.primitives?.[0]) return [0, 0, 0]\n        \n        const positionAccessorIndex = mesh.primitives[0].attributes?.POSITION\n        if (positionAccessorIndex === undefined) return [0, 0, 0]\n        \n        const accessor = accessors[positionAccessorIndex]\n        if (!accessor?.min || !accessor?.max) return [0, 0, 0]\n        \n        // Calculate center of bounding box\n        return [\n          (accessor.min[0] + accessor.max[0]) / 2,\n          (accessor.min[1] + accessor.max[1]) / 2,\n          (accessor.min[2] + accessor.max[2]) / 2\n        ]\n      } catch (error) {\n        return [0, 0, 0]\n      }\n    }\n\n    // Extract evidence points from nodes with meshes\n    nodes.forEach((node: any, index: number) => {\n      // Only process nodes that have meshes (actual objects)\n      if (node.mesh === undefined || !meshes[node.mesh]) return\n      \n      let name = node.name || `Object_${index}`\n      \n      // If the node has a generic name, use the filename instead\n      const lowerName = name.toLowerCase()\n      const isGenericName = name.startsWith('Object_') || \n                           name.startsWith('Node_') || \n                           lowerName.startsWith('geometry') ||\n                           name.startsWith('Mesh_') ||\n                           name === 'Scene' ||\n                           name === 'Root' ||\n                           /^(Object|Node|Mesh|Geometry)\\s*\\d+$/i.test(name)\n      \n      if (isGenericName && fileName && fileName !== 'room' && fileName !== 'scene') {\n        name = fileName\n      }\n      \n      // Get position from node translation OR calculate from mesh bounding box\n      let position: [number, number, number]\n      if (node.translation && node.translation.length === 3) {\n        position = [\n          Number(node.translation[0]) || 0,\n          Number(node.translation[1]) || 0,\n          Number(node.translation[2]) || 0\n        ]\n      } else {\n        // Calculate position from mesh geometry\n        position = getMeshCenter(node.mesh)\n      }\n      \n      const category = categorizeByName(name)\n      const label = formatNodeName(name)\n      \n      // Generate description based on category\n      let description = ''\n      if (category === 'evidence') {\n        description = `Critical evidence detected in scene. This item requires detailed forensic examination and documentation.`\n      } else if (category === 'furniture') {\n        description = `Furniture item that may contain trace evidence or provide spatial context for the investigation.`\n      } else if (category === 'anomaly') {\n        description = `Potential point of entry/exit or area of interest requiring further investigation.`\n      } else {\n        description = `Physical object present in scene. Position and state may be relevant to investigation timeline.`\n      }\n\n      evidencePoints.push({\n        id: `glb-${index}`,\n        label,\n        description,\n        position,\n        category,\n        confidence: 0.95 // High confidence - real scene data\n      })\n    })\n\n    console.log(`‚úÖ Extracted ${evidencePoints.length} evidence points from single GLB`)\n    evidencePoints.forEach((point, i) => {\n      console.log(`  Point ${i}: ${point.label} at [${point.position.map(p => p.toFixed(2)).join(', ')}]`)\n    })\n    return evidencePoints\n\n  } catch (error) {\n    console.error('Error extracting from single GLB:', error)\n    return []\n  }\n}\n\nfunction generateEvidencePoints(sceneName: string, description: string): EvidencePoint[] {\n  // Enhanced mock evidence detection - analyzes scene description for better results\n  const basePoints: EvidencePoint[] = []\n  \n  const sceneLower = sceneName.toLowerCase()\n  const descLower = description.toLowerCase()\n  console.log('Generating evidence for scene:', sceneName, 'lowercase:', sceneLower)\n  console.log('Description analysis:', descLower.substring(0, 100))\n  \n  // Analyze description for key terms\n  const hasBody = descLower.includes('body') || descLower.includes('victim') || descLower.includes('person')\n  const hasStruggle = descLower.includes('struggle') || descLower.includes('fight') || descLower.includes('disturbance')\n  const hasBlood = descLower.includes('blood') || descLower.includes('stain')\n  const hasWeapon = descLower.includes('weapon') || descLower.includes('knife') || descLower.includes('gun')\n  const hasFurniture = descLower.includes('furniture') || descLower.includes('sofa') || descLower.includes('chair') || descLower.includes('bed')\n  \n  // Room/Bathroom scenes\n  if (sceneLower.includes('room') || sceneLower.includes('bathroom')) {\n    console.log('Matched room/bathroom condition')\n    \n    if (hasBody) {\n      basePoints.push({\n        id: 'body-1',\n        label: 'Victim Position',\n        description: 'The body\\'s location and orientation are critical for understanding the sequence of events. Document exact position relative to room features.',\n        position: [0, 0, 0],\n        category: 'evidence',\n        confidence: 0.95,\n      })\n      basePoints.push({\n        id: 'body-2',\n        label: 'Immediate Surroundings',\n        description: 'Area immediately around the victim may contain trace evidence, fibers, or other materials transferred during the incident.',\n        position: [0.3, 0.1, 0.3],\n        category: 'evidence',\n        confidence: 0.88,\n      })\n    }\n    \n    if (hasStruggle) {\n      basePoints.push({\n        id: 'struggle-1',\n        label: 'Disturbance Area',\n        description: 'Signs of struggle or movement detected. Furniture displacement and object scattering indicate potential altercation.',\n        position: [-0.8, 0.5, 0.5],\n        category: 'anomaly',\n        confidence: 0.85,\n      })\n    }\n    \n    if (hasBlood) {\n      basePoints.push({\n        id: 'blood-1',\n        label: 'Blood Evidence Location',\n        description: 'Bloodstain pattern analysis required. Location and distribution may indicate sequence of events.',\n        position: [0.5, 0.05, -0.5],\n        category: 'evidence',\n        confidence: 0.92,\n      })\n    }\n    \n    if (hasWeapon) {\n      basePoints.push({\n        id: 'weapon-1',\n        label: 'Weapon Location',\n        description: 'Weapon positioning relative to victim and other evidence may indicate sequence of events or staging.',\n        position: [0.7, 0.1, 0.2],\n        category: 'evidence',\n        confidence: 0.90,\n      })\n    }\n    \n    if (hasFurniture) {\n      basePoints.push({\n        id: 'furniture-1',\n        label: 'Furniture Arrangement',\n        description: 'Furniture positioning inconsistent with normal room layout may indicate struggle, movement, or staging.',\n        position: [-1.2, 0.5, 1.1],\n        category: 'furniture',\n        confidence: 0.85,\n      })\n    }\n    \n    // Always add some general evidence points\n    if (basePoints.length === 0) {\n      basePoints.push(\n        {\n          id: 'general-1',\n          label: 'Primary Evidence Area',\n          description: 'Central area of the scene requiring comprehensive examination and documentation.',\n          position: [0, 0.3, 0],\n          category: 'evidence',\n          confidence: 0.80,\n        },\n        {\n          id: 'general-2',\n          label: 'Entry/Exit Point Analysis',\n          description: 'Examine access points for evidence of forced entry, disturbance, or staging.',\n          position: [1.5, 0.2, -1.2],\n          category: 'evidence',\n          confidence: 0.75,\n        },\n        {\n          id: 'general-3',\n          label: 'Secondary Evidence Zone',\n          description: 'Peripheral area may contain trace evidence, footprints, or displaced items.',\n          position: [-1.1, 0.1, 1.0],\n          category: 'evidence',\n          confidence: 0.70,\n        }\n      )\n    }\n  }\n  \n  if (sceneLower.includes('body')) {\n    console.log('Matched body condition')\n    basePoints.push(\n      {\n        id: '4',\n        label: 'Body Position',\n        description: 'Victim positioning and orientation',\n        position: [0, 0, 0],\n        category: 'evidence',\n        confidence: 0.95,\n      },\n      {\n        id: '5',\n        label: 'Surrounding Area',\n        description: 'Immediate area around body requires analysis',\n        position: [0.5, 0.1, 0.5],\n        category: 'evidence',\n        confidence: 0.80,\n      },\n    )\n  }\n  \n  if (sceneLower.includes('bag')) {\n    console.log('Matched bag condition')\n    basePoints.push(\n      {\n        id: '6',\n        label: 'Evidence Bag',\n        description: 'Collected evidence items',\n        position: [0, 0.5, 0],\n        category: 'object',\n        confidence: 0.90,\n      },\n    )\n  }\n  \n  if (sceneLower.includes('chair')) {\n    console.log('Matched chair condition')\n    basePoints.push(\n      {\n        id: '7',\n        label: 'Chair Position',\n        description: 'Furniture placement and orientation',\n        position: [0, 0, 0],\n        category: 'furniture',\n        confidence: 0.85,\n      },\n    )\n  }\n  \n  if (sceneLower.includes('mattress')) {\n    console.log('Matched mattress condition')\n    basePoints.push(\n      {\n        id: '8',\n        label: 'Bedding Evidence',\n        description: 'Mattress condition and positioning',\n        position: [0, 0.2, 0],\n        category: 'evidence',\n        confidence: 0.80,\n      },\n    )\n  }\n  \n  // Default evidence points if no specific matches\n  if (basePoints.length === 0) {\n    console.log('No specific matches, adding default evidence points')\n    basePoints.push(\n      {\n        id: 'default-1',\n        label: 'Scene Analysis Required',\n        description: 'General scene examination needed',\n        position: [0, 0.5, 0],\n        category: 'evidence',\n        confidence: 0.70,\n      },\n      {\n        id: 'default-2',\n        label: 'Area of Interest',\n        description: 'Location requiring detailed investigation',\n        position: [0.5, 0.2, -0.5],\n        category: 'evidence',\n        confidence: 0.65,\n      },\n    )\n  }\n  \n  console.log('Generated', basePoints.length, 'base evidence points')\n  \n  // Add some random variation to positions for realism\n  const finalPoints = basePoints.map(point => ({\n    ...point,\n    position: [\n      point.position[0] + (Math.random() - 0.5) * 0.3,\n      point.position[1] + (Math.random() - 0.5) * 0.2,\n      point.position[2] + (Math.random() - 0.5) * 0.3,\n    ] as [number, number, number],\n  }))\n  \n  console.log('Final evidence points:', finalPoints.length)\n  return finalPoints\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}